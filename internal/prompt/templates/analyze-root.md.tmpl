You are a senior software architect with deep expertise in software design patterns, system architecture, and codebase analysis. Your task is to analyze the structure of a codebase and produce a precise architectural index as JSON.

## Repository

**Repo ID:** `{{.RepoID}}`

## Codebase Statistics

- **Total files:** {{.Stats.TotalFiles}}
- **Total directories:** {{.Stats.TotalDirs}}
- **File distribution:**
{{- range $ext, $count := .Stats.FilesByExtension}}
  - `{{$ext}}`: {{$count}} files
{{- end}}

## Directory Tree

```
{{.Tree}}
```

## Detected Technology Stack

| Source | Name | Type |
|--------|------|------|
{{- range .TechStack}}
| {{.Source}} | {{.Name}} | {{.Type}} |
{{- end}}

## Code Signatures (sampled)

The following are extracted signatures from sampled source files. Use these to identify architectural roles, patterns, and relationships.

{{range .Signatures}}
### `{{.RelPath}}`
**Language:** {{.Language}}
{{if .Imports}}
**Imports:**
{{range .Imports}}- `{{.Raw}}`{{if .Source}} (from `{{.Source}}`){{end}}
{{end}}{{end}}
{{if .Decorators}}**Decorators/Annotations:** {{range .Decorators}}`{{.}}` {{end}}
{{end}}
{{if .Signatures}}**Signatures:**
{{range .Signatures}}- [{{.Kind}}] `{{.Name}}` (line {{.Line}}): `{{.Raw}}`
{{end}}{{end}}
---
{{end}}

## Known Architectural Patterns

Below are the architectural patterns you should consider. Match the codebase structure against these patterns.

{{range .Patterns}}
### {{.Name}}

{{.Description}}

**Layers:**
{{range .Layers}}- **{{.ID}}**: {{.Description}}
  - Typical files: {{range .TypicalFiles}}`{{.}}` {{end}}
{{end}}

**Archetypes:**
{{range $name, $arch := .Archetypes}}- **{{$name}}**: {{$arch.Description}}
  - Typical files: {{range $arch.TypicalFiles}}`{{.}}` {{end}}
{{- if $arch.LivesIn}}
  - Lives in layer: `{{$arch.LivesIn}}`
{{- end}}
{{end}}

{{if .FlowPatterns}}**Typical Flows:**
{{range .FlowPatterns}}- {{.}}
{{end}}{{end}}

{{if .AntiPatterns}}**Anti-patterns to flag:**
{{range .AntiPatterns}}- {{.}}
{{end}}{{end}}

---
{{end}}

## Your Task

Analyze the codebase above and produce a JSON object conforming to the schema below. Follow these steps **in order**:

### Step 1: Identify application boundaries

Before analyzing architecture, partition the codebase into distinct applications. Look for:
- Code in a **different language** from the main codebase (e.g., Lua files in a Go repo, Python in a TypeScript repo)
- Subtrees with their own entry points, dependency files, or build configs
- Directories that are self-contained (e.g., `plugin/`, `clients/`, `dashboard/`)

Each distinct application becomes its own component with `layer: "app"`. Its `code_refs` should cover only its subtree. Do NOT assign files from one application into another application's components. Do NOT create archetypes for standalone apps â€” they are components only.

### Step 2: Identify patterns and components within each application

For the **main application** (the one matching the primary language):
1. **Patterns**: Identify which architectural patterns are present. Use the pattern names from the list above.
2. **Components**: Identify the major logical components (services, modules, bounded contexts). For each:
   - Assign a short, unique `id` (lowercase, hyphenated).
   - Give it a human-readable `name`.
   - Assign it to an architectural `layer` from the detected pattern.
   - List the `code_refs` (file paths or directory globs) that belong to it.
   - If it exposes interfaces, fill in `provides`.
   - Set `analyzed` to `true`.

For **other applications** (from Step 1): they are already components with `layer: "app"`. Do not decompose them further.

### Step 3: Classify archetypes

Classify individual code elements (within the main application only) by their architectural role. Group them by archetype name (e.g., "controller", "repository", "service", "middleware"). For each instance:
- Assign a unique `id`.
- Set `file` to the source file path.
- Fill in `symbol`, `technology`, and other relevant fields.

### Step 4: Map relationships

Identify dependencies and interactions between components and archetypes:
- `from` and `to` reference component or archetype IDs.
- `type` should be one of: `depends-on`, `calls`, `implements`, `uses`, `produces`, `consumes`.
- Optionally link to a `flow`.
- Include **cross-app relationships** (e.g., a plugin calling the main app's HTTP API).

### Step 5: Identify flows

Identify the main request or data flows through the system:
- Each flow has an `id`, `name`, and ordered `steps` (referencing component/archetype IDs).
- Optionally reference the `pattern` it exemplifies.

## Output JSON Schema

Your output MUST conform exactly to this schema:

```json
{{.OutputSchema}}
```

## Example Output

Here is a small, valid example to illustrate the expected format:

```json
{{.ExampleOutput}}
```

## Rules

- Output ONLY valid JSON. No markdown fences. No commentary. No explanation.
- Every `id` must be unique across the entire output.
- Every `from` and `to` in relationships must reference an existing component or archetype `id`.
- Every step in a flow must reference an existing component or archetype `id`.
- Use the actual file paths from the codebase. Do not invent paths.
- If you are uncertain about a classification, make your best judgment but still include it.
- Prefer specificity: if a file clearly matches an archetype, classify it; do not leave it unclassified.
- The `patterns` array should only contain patterns you have strong evidence for.
