You are analyzing the structure of a codebase to produce an architectural index. You will be given a directory tree and file distribution. From these, you must infer the architecture, components, and relationships.

## Repository

**Repo ID:** `{{.RepoID}}`

## File Distribution
{{range $ext, $count := .Stats.FilesByExtension}}
- `{{$ext}}`: {{$count}} files
{{- end}}

## Directory Tree

```
{{.Tree}}
```

## Architectural Pattern Reference
{{range .Patterns}}
### {{.Name}}

{{.Description}}

**Layers:**
{{range .Layers}}- **{{.ID}}**: {{.Description}}
  - Typical files: {{range .TypicalFiles}}`{{.}}` {{end}}
{{end}}

**Archetypes:**
{{range $name, $arch := .Archetypes}}- **{{$name}}**: {{$arch.Description}}
  - Typical files: {{range $arch.TypicalFiles}}`{{.}}` {{end}}
{{- if $arch.LivesIn}}
  - Lives in layer: `{{$arch.LivesIn}}`
{{- end}}
{{end}}

{{if .FlowPatterns}}**Typical Flows:**
{{range .FlowPatterns}}- {{.}}
{{end}}{{end}}

{{if .AntiPatterns}}**Anti-patterns to flag:**
{{range .AntiPatterns}}- {{.}}
{{end}}{{end}}

---
{{end}}

## Instructions

Analyze the directory tree above and produce a JSON architectural index. You must infer languages, frameworks, and architectural roles from directory names, file names, and extensions alone.

Work through these steps in order:

### Step 1: Partition into applications

A repository may contain multiple distinct applications. Look for:
- Subtrees in a **different language** (e.g., Lua files in a Go repo, a `dashboard/` with `.tsx` files)
- Subtrees with their own build/dependency files (`package.json`, `go.mod`, `Cargo.toml`)
- Self-contained directories (`plugin/`, `clients/`, `tools/`)

Each distinct application becomes a component with `layer: "app"`. Do NOT decompose it further â€” no archetypes, no sub-components. Its `code_refs` cover only its subtree.

If the repository is a single application, skip this step.

### Step 2: Detect architectural patterns

For the **main application** only, identify which architectural patterns from the reference above are present. Evidence comes from directory structure and naming conventions (e.g., `domain/`, `adapters/`, `controllers/`, `models/`).

Only include patterns you have strong evidence for.

### Step 3: Identify components

Decompose the main application into logical components (services, modules, bounded contexts):
- Assign each a unique `id` (lowercase, hyphenated), a human-readable `name`, and a `layer` from the detected pattern.
- `code_refs` should use file paths or directory globs from the tree.
- Every source file in the main application should belong to exactly one component.

### Step 4: Classify archetypes

Within the main application, classify individual files by their architectural role. Group by archetype name (`controller`, `repository`, `service`, etc.). For each:
- `id`: unique across the entire output
- `file`: exact path from the tree
- `symbol`: primary class/function name (infer from file name)
- `technology`: infer from file extensions, directory names, or common conventions

**Do NOT create archetypes for `app`-layer components.** Archetypes are only for the main application.

### Step 5: Map relationships

Identify dependencies between components and archetypes:
- `type`: one of `depends-on`, `calls`, `implements`, `uses`, `produces`, `consumes`
- Include cross-application relationships where evident (e.g., a plugin calling the main app's API)

### Step 6: Identify flows

Trace the main request/data flows through the system. Each flow is an ordered list of component/archetype IDs representing how a request or event moves through the architecture.

## Output Schema

```json
{{.OutputSchema}}
```

## Example

```json
{{.ExampleOutput}}
```

## Output Rules

- Output ONLY valid JSON. No markdown fences, no commentary.
- Every `id` must be unique across the entire output (components, archetypes, flows).
- Every `from`/`to` in relationships and every step in flows must reference an existing `id`.
- Use actual file paths from the tree. Do not invent paths.
- `repo_id` must be `{{.RepoID}}`.
