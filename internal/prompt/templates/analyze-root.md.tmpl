You are analyzing the structure of a codebase to produce an architectural index. You will be given a directory tree and file distribution. From these, infer the architecture, components, and relationships using directory names, file names, and extensions.

## Repository

**Repo ID:** `{{.RepoID}}`

## File Distribution
{{range $ext, $count := .Stats.FilesByExtension}}
- `{{$ext}}`: {{$count}} files
{{- end}}

## Directory Tree

```
{{.Tree}}
```

## Architectural Pattern Reference
{{range .Patterns}}
### {{.Name}}

{{.Description}}

**Layers:**
{{range .Layers}}- **{{.ID}}**: {{.Description}}
  - Typical files: {{range .TypicalFiles}}`{{.}}` {{end}}
{{end}}

**Archetypes:**
{{range $name, $arch := .Archetypes}}- **{{$name}}**: {{$arch.Description}}
  - Typical files: {{range $arch.TypicalFiles}}`{{.}}` {{end}}
{{- if $arch.LivesIn}}
  - Lives in layer: `{{$arch.LivesIn}}`
{{- end}}
{{end}}

{{if .FlowPatterns}}**Typical Flows:**
{{range .FlowPatterns}}- {{.}}
{{end}}{{end}}

{{if .AntiPatterns}}**Anti-patterns to flag:**
{{range .AntiPatterns}}- {{.}}
{{end}}{{end}}

---
{{end}}

## Instructions

Work through these steps in order.

### Step 1: Identify project boundaries

Partition the repository into distinct projects. Evidence:
- Subtrees in a **different language** (e.g., Lua in a Go repo, TypeScript in a Java repo)
- Subtrees with their own build/dependency files (`package.json`, `go.mod`, `pom.xml`, `build.gradle`)
- Self-contained directories (`plugin/`, `clients/`, `tools/`)

Each distinct project becomes a component with `layer: "app"`. Do NOT decompose it further — no archetypes, no sub-components. Its `code_refs` cover only its subtree.

**Not separate projects:** test directories, sample/example directories, documentation, build configuration. These belong to the project they support.

If the repository is a single project, skip this step.

### Step 2: Detect architectural patterns

For the **main project**, identify architectural patterns. Use the reference patterns above where they fit, but also identify other patterns evident from the structure (e.g., Filter Chain, Provider/Strategy, Plugin Architecture, Event-Driven, Layered/N-Tier).

Include a pattern only when there is clear structural evidence — directory naming, file conventions, or layering in the tree.

### Step 3: Identify components

Decompose the main project into components that represent **cohesive subsystems**, not just individual directories.

Guidance on granularity:
- **Group tightly coupled directories** into one component when they form a single subsystem (e.g., a template engine + its schema definitions = one component).
- **Decompose large subsystems** that have their own internal layering. If a directory contains distinct layers (entry points, business logic, data access), it should be multiple components, not one.
- Components should map to things a developer would describe as "the X subsystem" — not every package, but not the whole app either.

For each component:
- `id`: unique, lowercase, hyphenated
- `name`: human-readable
- `layer`: from the detected pattern (or a descriptive layer name if using a non-reference pattern)
- `code_refs`: file paths or directory globs from the tree
- Set `analyzed` to `true`

Every source file in the main project should belong to exactly one component.

### Step 4: Classify archetypes

Within the main project, classify individual files by their architectural role. Group by archetype name (`controller`, `repository`, `service`, `filter`, `provider`, `configurer`, etc.). For each:
- `id`: unique across the entire output
- `file`: exact path from the tree
- `symbol`: primary class/function name (infer from file name)
- `technology`: infer from extensions, directory names, or conventions

**Do NOT create archetypes for `app`-layer components.** Archetypes apply only to the main project.

### Step 5: Map relationships

Identify dependencies between components and archetypes:
- `type`: one of `depends-on`, `calls`, `implements`, `uses`, `produces`, `consumes`
- Include cross-project relationships where evident (e.g., a plugin calling the main project's API)
- Relationships should reflect the dependency direction: entry points depend on services, services depend on repositories.

### Step 6: Identify flows

Trace the main request/data flows. Start from entry points (CLI commands, HTTP endpoints, event handlers) and follow the path through the system. Each flow is an ordered list of component/archetype IDs.

## Output Schema

```json
{{.OutputSchema}}
```

## Example

```json
{{.ExampleOutput}}
```

## Output Rules

- Output ONLY valid JSON. No markdown fences, no commentary.
- Every `id` must be unique across the entire output (components, archetypes, flows).
- Every `from`/`to` in relationships and every step in flows must reference an existing `id`.
- Use actual file paths from the tree. Do not invent paths.
- `repo_id` must be `{{.RepoID}}`.
